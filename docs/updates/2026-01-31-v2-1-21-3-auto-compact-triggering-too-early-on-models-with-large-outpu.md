---
title: "大容量出力モデルでのauto-compact早期トリガー問題を修正"
date: 2026-01-28
tags: ['バグ修正', 'パフォーマンス', 'コンテキスト管理']
---

## 原文（日本語に翻訳）

大きな出力トークン制限を持つモデルで、auto-compactが早期にトリガーされる問題を修正

## 原文（英語）

Fixed auto-compact triggering too early on models with large output token limits

## 概要

Claude Opus 4.5などの大きな出力トークン制限を持つモデルにおいて、会話コンテキストの自動圧縮（auto-compact）が必要以上に早く実行される問題が修正されました。以前は、モデルの能力を考慮せず一律の基準でコンパクション（会話履歴の要約・圧縮）がトリガーされていたため、まだ十分な余裕があるにもかかわらず会話が圧縮され、情報の損失や応答速度の低下が発生していました。v2.1.21では、各モデルの出力トークン制限に応じて適切なタイミングでコンパクションが実行されるようになりました。

## 基本的な使い方

この修正は自動的に適用されるため、特別な設定は不要です。モデルの能力に応じて最適なタイミングでコンテキスト管理が行われます。

```bash
# Opus 4.5などの大容量モデルを使用
claude code --model opus

# 長い会話でも適切なタイミングまでコンパクションが実行されない
```

## 実践例

### 大規模コードベースの分析

大きなプロジェクトを分析する際、複数のファイルを読み込んでも早期に圧縮されることがなくなります：

```bash
$ claude code --model opus
> プロジェクト内の全てのReactコンポーネントを分析して、状態管理のパターンを抽出して

# v2.1.21以降: モデルの大容量出力能力を活かし、
# より多くのファイル情報を保持したまま分析が可能

# v2.1.20以前: 早期にコンパクションが発生し、
# 一部のファイル情報が要約されて詳細が失われる可能性
```

### 長時間のデバッグセッション

複雑なバグを追跡する際、会話履歴がより長く保持されます：

```bash
$ claude code --model opus
> このエラーの原因を調査して
[複数のファイルを読み込み、ログを分析...]

> さらに関連するファイルを確認して
[追加のファイルを読み込み...]

> 最初に読んだファイルAの情報をもう一度参照して
# 適切なタイミングまでコンパクションが実行されないため、
# 初期の情報も失われずに参照可能
```

### リファクタリング作業

複数のファイルにまたがるリファクタリングで、コンテキストの保持が向上：

```bash
$ claude code --model opus
> src/以下の全ファイルでAPI呼び出しのパターンを統一して

# Opusの大容量出力能力により、
# より多くのファイルを同時にコンテキストに保持し、
# 一貫性のあるリファクタリングが可能
```

## 注意点

- この修正はv2.1.21で適用されました
- 特にOpus 4.5のような大容量出力モデルで効果が顕著です
- SonnetやHaikuでも、それぞれのモデルに最適化されたタイミングでコンパクションが実行されます
- コンパクションは会話が長くなりすぎた際の自動的な最適化機能です
- 手動でコンテキストをクリアしたい場合は `/clear` コマンドを使用できます
- モデルのトークン制限に達すると、最終的にはコンパクションが実行されます（これは正常な動作です）

## 関連情報

- [Claude Code 公式ドキュメント](https://code.claude.com/docs/)
- [Changelog v2.1.21](https://github.com/anthropics/claude-code/releases/tag/v2.1.21)
- [コンテキスト管理ガイド](https://code.claude.com/docs/context-management)
