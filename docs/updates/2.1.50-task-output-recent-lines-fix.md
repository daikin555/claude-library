---
title: "クリーンアップ後にTaskOutputが最近の行を保持し続けるメモリリークを修正しました"
date: 2026-02-21
tags: [bug-fix, memory, performance]
---

## 原文（日本語に翻訳）

クリーンアップ後にTaskOutputが最近の行を保持し続けるメモリリークを修正しました。

## 原文（英語）

Fixed memory leak where TaskOutput retained recent lines after cleanup

## 概要

タスクの出力（TaskOutput）をクリーンアップした後も、最近実行された行のデータが内部バッファに残り続ける問題が修正されました。タスク出力が「クリーンアップ済み」の状態でも、最近の出力行が参照可能な状態でメモリに保持されており、多数のタスクを実行するセッションでメモリが蓄積していました。

## 基本的な使い方

この修正は自動的に適用されます。多数のコマンドやタスクを実行する長いセッションで効果が現れます。

```bash
# 多数のコマンドを実行するセッション
claude

> bashコマンドを実行して出力を確認して
> 別のコマンドを実行して
> さらに別のコマンドを実行して

# v2.1.50以降: 各コマンドの出力がクリーンアップ後に完全に解放される
# 以前: クリーンアップ後も最近の行がメモリに残っていた
```

## 実践例

### ユースケース1: 継続的なコマンド実行セッション

多数のシェルコマンドを順番に実行する場合。

```bash
claude

# コマンドを次々と実行
> npm run build を実行して出力を確認して
# ビルド出力（数百行） → クリーンアップ → 完全解放（修正後）

> npm test を実行して失敗テストを確認して
# テスト出力（数百行） → クリーンアップ → 完全解放（修正後）

> git log --oneline -100 を実行して確認して
# git log出力 → クリーンアップ → 完全解放（修正後）

# 修正前: 各コマンドの最近の行がメモリに残り蓄積
# 修正後: 完全に解放されメモリが安定
```

### ユースケース2: ログ分析の繰り返し実行

大量のログを何度も分析する場合。

```bash
claude

# 複数のログファイルを順番に分析
> cat /var/log/app.log | tail -1000 の出力を分析して
# 1000行のログ出力 → 分析完了 → 完全解放

> cat /var/log/error.log | head -500 を分析して
# 500行のエラーログ → 分析完了 → 完全解放

# メモリ使用量が安定
```

### ユースケース3: バックグラウンドタスクの大量実行

バックグラウンドエージェントが多数のタスクを実行する場合。

```bash
claude

# バックグラウンドエージェントが多数のサブタスクを実行
> @batch-processor 100個のファイルを順番に処理して

# 各ファイルの処理出力が：
# - 処理完了後にクリーンアップ
# - 修正後: 最近の行も含めて完全に解放
# → 100タスク実行後もメモリが安定
```

## 注意点

- この問題はTaskOutput内の「最近の行」バッファに関するものです。完全な出力履歴とは別の問題です。
- `TaskOutput` の別のメモリリーク（「completed task output was not freed」）とは異なる箇所の修正です。v2.1.50では両方が修正されています。
- クリーンアップはタスク完了後に内部的に行われます。ユーザーが意識する必要はありません。

## 関連情報

- [Claude Code 公式ドキュメント](https://docs.anthropic.com/ja/docs/claude-code/overview)
- [Claude Code CHANGELOG](https://github.com/anthropics/claude-code/blob/main/CHANGELOG.md)
- [完了タスク出力のメモリ修正](./2.1.50-task-output-memory-fix.md)
- [CircularBufferのメモリ修正](./2.1.50-circular-buffer-memory-fix.md)
